---
layout: page
title: Libraries
---

* auto-gen TOC:
{:toc}

Testing
-------
[hspec][] is pretty great. Define a `test/Spec.hs`:

{% highlight haskell %}
{-# OPTIONS_GHC -F -pgmF hspec-discover #-}
{% endhighlight %}

And then write tests like `test/Data/ListSpec.hs`
(borrowed from the hspec website):

{% highlight haskell %}
import Test.Hspec
import Test.QuickCheck
import Control.Exception (evaluate)

main :: IO ()
main = hspec $ do
  describe "Prelude.head" $ do
    it "returns the first element of a list" $ do
      head [23 ..] `shouldBe` (23 :: Int)

    it "returns the first element of an *arbitrary* list" $
      property $ \x xs -> head (x:xs) == (x :: Int)

    it "throws an exception if used with an empty list" $ do
      evaluate (head []) `shouldThrow` anyException
{% endhighlight %}

The above example also uses [QuickCheck][], which allows you to specify
properties that are tested with a bunch of autogenerated values.

For continuous integration [CircleCI][] is pretty good, and free for open-source
projects. [circle-stack][] is a set of Bash scripts for running tests on
CircleCI with stack.

[hspec]: http://hspec.github.io/
[QuickCheck]: https://hackage.haskell.org/package/QuickCheck
[CircleCI]: https://circleci.com
[circle-stack]: https://github.com/ssilab/circle-stack

CLIs
----
Use [optparse-applicative][] to make nice CLIs. Remember to use `helper` on both
the top level and any subparsers so you can `--help` when you inevitably forget
what name to gave that one flag.

[optparse-applicative]: http://hackage.haskell.org/package/optparse-applicative

Filesystem
----------
[directory][] contains a bunch of useful functions for querying the filesystem.
Take particular note of [getXdgDirectory][], which tells you where you should
store and look for user-specific config files and cross-execution cache.

For super-simple file reading and writing, the functions in [bytestring][] are
fine. If you want to do streaming input and output, look into [pipes][].

The default `FilePath` is actually just a synonym for `String`. The [path][]
package provides a more strongly-typed `Path` type. [path-io][] (not on Hackage)
provides some IO and parsing functions that use this `Path` type so you don't
need to `toFilePath` all the time.

[directory]: https://hackage.haskell.org/package/directory
[getXdgDirectory]: https://hackage.haskell.org/package/directory-1.2.5.0/docs/System-Directory.html#v:getXdgDirectory
[bytestring]: https://hackage.haskell.org/package/bytestring
[pipes]: https://hackage.haskell.org/package/pipes
[path]: https://hackage.haskell.org/package/path
[path-io]: https://github.com/rimmington/path-io

Concurrency
-----------
[async][] is a good threading abstraction that helps ensure you don't forget
about exceptions in child threads. The `withAsync` and `Concurrently`
abstractions are useful for ensuring no threads are left running.

{% highlight haskell %}
web, updater, enacter, monitor :: IO ()

runConcurrently $ Concurrently web
              <|> Concurrently updater
              <|> Concurrently enacter
              <|> Concurrently monitor
{% endhighlight %}

For communication, default to [Software Transactional Memory][STM]. STM takes
a transactional approach that helps ensure your application does not end up in
an invalid state.

Some additional (non-STM) synchronisation primitives are in the
[concurrent-extra][] package, such as a `Broadcast` type to wake multiple
threads.

[async]: https://hackage.haskell.org/package/async
[STM]: https://hackage.haskell.org/package/stm
[concurrent-extra]: https://hackage.haskell.org/package/concurrent-extra

Web
---
[Servant][servant] is a stand-out set of libraries in this space, and makes
writing type-safe web services pleasant: write functions between the types in
your API and let servant handle the busywork. Features auto-generation of
client-side code. It is missing some features like authentication at this point
though.

You can use servant to write clients for existing web services too.

[servant]: http://haskell-servant.github.io/

Persistence
-----------
The [persistent][] package is decent enough.

[persistent]: https://hackage.haskell.org/package/persistent

Parsing
-------
For JSON, use [Aeson][]. It has template Haskell functions that auto-generate
de/encoding functions, or you can write your own using the Aeson AST. Plus you
get [yaml][] for free.

When you need to write your own parser, start with [megaparsec][] and then
switch to [attoparsec][] if you need more speed.

[Aeson]: https://hackage.haskell.org/package/aeson
[yaml]: https://hackage.haskell.org/package/yaml
[megaparsec]: https://hackage.haskell.org/package/megaparsec
[attoparsec]: https://hackage.haskell.org/package/attoparsec

Lenses
------
[microlens][] is a minimal-dependency lens implementation, while [lens][] is the
full kitchen sink. Basics:

{% highlight haskell %}
{-# LANGUAGE TemplateHaskell #-}
$(makeLenses ''Person)
$(makeLenses ''Address)

bob     :: Person
address :: Lens' Person Address
street  :: Lens' Address Text
number  :: Lens' Address Natural

address . street :: Lens' Person Text
address . number :: Lens' Person Natural

bob ^. address          :: Address
bob ^. address . street :: Text

address . street .~ "Boring Ave"       :: Person -> Person
bob & address . street .~ "Boring Ave" :: Person

address . number %~ (+ 1) :: Person -> Person
{% endhighlight %}

[microlens]: https://hackage.haskell.org/package/microlens
[lens]: https://hackage.haskell.org/package/lens

Time
----
Use [time][]. See also the [Haskell Wiki page][time-types] for information on
the types in that library. Always store times in UTC (`UTCTime`), and then
convert to the local time zone for display.

[time]: https://hackage.haskell.org/package/time-1.6
[time-types]: https://wiki.haskell.org/Time
